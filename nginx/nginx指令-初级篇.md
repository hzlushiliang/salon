# nginx指令-初级篇 #

__关键词: nginx 指令 参数 优先级__

    worker_processes  1;

    events {
        worker_connections  1024;
    }

    http {
        default_type  application/octet-stream;
        access_log  logs/access.log  main;

        server {
            listen       80;
            server_name  localhost;

            location / {
                root   html;
                index  index.html index.htm;
            }
        }
    }

上面的桥段想必大家都很眼熟，我们可能会把`worker_processes`增大到100，以提高并发能力，我们可能也会把`access_log`设置成我们的特殊路径，方便日志统一管理，我们也可能会将`server_name`换成自己的实际域名，根据域名过滤http请求，话说这些指令项的原理到底是什么呢，怎么实现如何工作的，删繁就简，再眼花缭乱的nginx配置，其实就两个核心的东东

* 指令，比如上面的`worker_processes`和`server_name`
* 参数，比如上面的80和html

参数隶属指令，也就是说参数归指令管。既然被管着，那就不是自由的，大家小时候都被父母管着，女同学的头发不能揪，老师布置的作业要按时做完，自由吗，不自由，参数也不是随意写的，像`listen cool;`这种搞法就是错误的，nginx压根就没法启动，本来`listen`指令后面应该紧跟着一个数字，代表端口，nginx启动的时候会给当前虚拟主机创建一个监听套接字，后者监听在这个数字端口上，你塞给nginx一串字符，nginx自然会懵逼，可见一个指令后面的参数被种种条条框框约束着，具体怎么约束就看指令是怎么定义的了，打个比方

    { ngx_string("allow"),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LMT_CONF|NGX_CONF_TAKE1,
      ngx_http_access_rule,
      NGX_HTTP_LOC_CONF_OFFSET,
      0,
      NULL },

上面这波操作定义了一个指令，指令名字叫做`allow`，同时对指令的参数做了如下的明文约束

* 参数有且只有一个，`NGX_CONF_TAKE1`表达的就是这个意思

这是最基本的约束，如果你塞给allow指令两个参数，打个比方说`allow nice good`，nginx引擎会失败退出，因为你的使用姿势有问题，还可以玩的花一点，猫腻就在`ngx_http_access_rule`中，这是一个自定义接口，我们可以对每个参数做各种校验和转换，比如说要求参数必须是大于0的数字，否则勒令nginx引擎失败退出，对应下面这波操作

    static char* ngx_http_hzlushiliang_age(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {
        ngx_int_t  age;
        ngx_str_t  *value,
        ngx_http_hzlushiliang_main_conf_t  *hmcf;

        value = cf->args->elts;
        hmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_hzlushiliang_module);

        if (cf->args->nelts < 2) {
            return NGX_CONF_ERROR;
        }

        age = ngx_parse_size(&value[1]);
        if (age == NGX_ERROR || age <= 0) {
            return NGX_CONF_ERROR;
        }

        hmcf->age = age;
        return NGX_CONF_OK;
    }
    
我们把nginx传递进来的参数转换成整型，如果转换失败或者转换后小于等于0，那么返回异常给nginx，只有大于0的情况，我们才返回成功给nginx，继续后续的处理，除此之外，还可以指定参数是必须长度小于10的字符串，第二个参数比第一个参数大等，就看你想怎么玩了，现在对参数做一个简单的总结

* 参数的个数是有限制的，最多是`8`个，也有一些特殊的指令，参数都不带，对应`NGX_CONF_NOARGS`，还有一些指令的参数个数很玄幻，不受限制，只要不超过8个即可
* 参数除了受到个数的约束，每个参数还会受到取值的约束，这个因指令不同而不同，一般我都是直接看该指令的源码实现，如果你不熟悉，可以google一下相关指令的使用说明

参数相对简单一些，相比之下，指令理解起来可能会比较复杂，从开发者的角度来说，我们设计开发一个新的指令，需要在自己的http模块中，生产如下的原材料

1. 指令名称，不要和nginx自带的模块指令冲突，不然nginx看到这个指令，傻傻分不清
2. 指令的活动范围，也就是指令可以在配置文件中的哪些位置使用
3. 指令的参数个数，前面说过了
4. 指令处理接口，如果nginx看到这条指令，就会调用该接口，将指令名称和所有参数摆在桌上，让你处理
5. 指令存储在哪个柜子中
6. 指令存储在柜子的第几个格子中

先说指令名称，指令名称唯一标示了一个指令，所以起名字的时候最好个性化一点，这样能和nginx的其他模块指令区分开来，如果你的指令名称和nginx自带的模块指令冲突了，会发生很有趣的现象，nginx不一定会把该指令认错成哪一个，nginx在配置文件中碰到该指令，会拿着该指令和它的参数，去扫描所有模块，挨个比对所有模块的所有指令信息，如果先碰到了其他模块的同名指令，可能会失败退出，但是也可能会继续跑着，尤其是当你们两个的指令很像的时候，不仅名称一样，参数活动范围类似，参数个数也类似，这其实都是非常不必要的，名字那么多，起的时候稍微注意一下

指令的活动范围，顾名思义，就是指令可以出现在配置文件的哪些地方，nginx的配置文件是划分区域的，http模块有自己的区域，非http模块也有自己的区域，非http模块包括EVENT和MAIL模块等，非http模块就不管了，定制化的需求不多，有定制需求的基本都是http模块，而http模块又划分了很多区域

    #define NGX_HTTP_MAIN_CONF        0x02000000
    #define NGX_HTTP_SRV_CONF         0x04000000
    #define NGX_HTTP_LOC_CONF         0x08000000
    #define NGX_HTTP_UPS_CONF         0x10000000
    #define NGX_HTTP_SIF_CONF         0x20000000
    #define NGX_HTTP_LIF_CONF         0x40000000
    #define NGX_HTTP_LMT_CONF         0x80000000

这些区域是相互嵌套的关系，MAIN只有一个，SRV是MAIN的子区域，可以有多个，LOC是SRV的子区域，也可以有多个，这三个也是用的最多的，nginx在配置文件中碰到该指令，会标记下该指令出现的区域，然后和我们指定的合法区域做一个比对，如果比对有出入，比如说我们设计该指令只能出现在SRV域，结果在MAIN域抓到了该指令，nginx引擎会失败退出，更常见的情况是，我们会设计一个指令既可以出现在MAIN域，也可以出现在SRV域和LOC域，既然有多个相同的指令，最后到底听哪一个的呢，这就涉及到指令优先级设计和指令信息合并了，最后收尾的时候我们再单独拎出来说

指令参数个数，开篇已经讲过了，这里不再赘述

指令处理接口，这个接口前面举过例子，但是这里再说的通俗易懂一些，nginx引擎在配置中遇到一条指令，会去扫描全局的模块数组，从某个模块中揪出这条指令的相关信息，然后调用指令处理接口，把指令名称，指令后面跟着的所有参数，还有指令临时存储的柜子中的格子传递进去，我们就可以在接口内部对参数做各种预处理，没问题了就将参数存放在格子中暂存起来

指令存储的柜子，其实是我们自定义的一个结构体，专门用来存储指令配置信息的，每个http模块都有自己的柜子，而且柜子还分三种类型

1. MAIN类型柜子，nginx引擎的正室
2. SRV类型柜子，nginx引擎的二房
3. LOC类型柜子，nginx引擎的三房

虽然正室二房和三房的名称看上去很想当然，但是各位千万不要想当然，正室就是用来存储在MAIN域捕捉到的指令信息的吧，二房存储SRV域指令信息，三房存储LOC域指令信息，`错错错`，他们没有什么必然的关系，一条出现在MAIN域的指令信息，可以存储在三房那里，而一条出现在LOC域的指令信息，可以存储在正室那里，这些我们说了算，nginx不管这些，正室二房和三房都可以跟nginx引擎生儿子，现在国家放开二胎了，但是正室只生一胎，而二房繁殖能力强，可以生好几胎，三房更是超生队的，生的比二房还多，假如现在有1个MAIN域，3个SRV域，6个LOC域，那么正室还是只生`1`胎，而二房要生`1 + 3 = 4`胎，三房要生`1 + 3 + 6 =10`胎，为什么会这样呢

* 在MAIN域（北京），nginx引擎跟正室生1胎，给二房生1胎，给三房生1胎
* 在每个SRV域（杭州，南京等），nginx引擎跟二房生1胎，给三房生1胎
* 在每个LOC域（宁波，舟山，绍兴等），nginx引擎跟三房生1胎

柜子中的格子，可以理解为结构体中的某个成员变量，每个柜子都有好几个格子，对应一个结构体中的若干个成员变量

有了前面的余粮，我们再来啃掉指令优先级这块硬骨头，一个指令可以同时出现在MAIN域，SRV域和LOC域，也就是一个指令可以出现很多次，但是一个HTTP请求进来，肯定是匹配到某个LOC域中去的，否则就丢弃了，在处理这个HTTP请求的时候，我们只能拿到唯一的一个正室儿子，唯一的一个二房儿子，唯一的一个三房儿子，这三个儿子是当前HTTP请求所能看到的所有配置信息，后者用于辅助HTTP请求的处理，但是如果一个指令同时出现在了MAIN域，父亲SRV域和当前LOC域，而且我们设计将这个指令的信息存储到三房儿子手中，那到底是听北京三房儿子的呢，还是杭州三房儿子的呢，还是宁波三房儿子的呢，nginx提供了两个接口来做指令优先级处理和指令信息合并

    ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);
    ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);

    void       *(*create_main_conf)(ngx_conf_t *cf);
    char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

    void       *(*create_srv_conf)(ngx_conf_t *cf);
    char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);

    void       *(*create_loc_conf)(ngx_conf_t *cf);
    char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);
    
其中`merge_srv_conf`和`merge_loc_conf`接口就是干这个的，前者会将北京三房儿子和杭州三房儿子传递进来，我们可以做进一步的处理，合并完的最新信息存放到杭州三房儿子这里，接着`merge_loc_conf`会再次合并杭州三房儿子与宁波三房儿子的配置信息，最终的配置信息会听宁波三房儿子的，至于两个儿子的信息怎么合并，这个要看我们怎么玩，一般来说，如果村里儿子没有配置信息，那么就将城里儿子的配置信息下放给村里儿子，也就是配置优先级从低到高

* 北京三房儿子 < 杭州三房儿子 < 宁波三房儿子

当然我们也可以反过来，如果城里的儿子有配置，那么不管村里儿子有没有，都听城里的，也就是配置优先级从高到低

* 北京三房儿子 > 杭州三房儿子 > 宁波三房儿子

不是吓唬大家，虽然你可能只是简单用一用nginx，就算做nginx二次开发，也可以不定义自己的指令，但是如果你不懂nginx的指令引擎，你玩不转nginx，在nginx的世界里也会寸步难行，绝大部分nginx内置的http模块，包括核心http模块，都有自己的指令集，我们用nginx，用的也是这些指令集，如果用着用着出问题了，回头看看这篇文章，兴许能有点启发和帮助

最后做一个简单的总结，通过nginx的指令引擎，我们可以做什么呢

* 定义自己的指令，可以不定义，也可以定义多个
* 定义指令的合法活动范围
* 定义指令的参数个数
* 定义参数的复杂约束条件
* 定义指令信息存储的正室，二房和三房长什么样
* 定义指令存储到正室儿子，二房儿子还是三房儿子
* 定义指令的优先级和如何合并
* 定义指令加载前的处理方式
* 定义指令加载后的处理方式
* 通过参数变量编译的方式加速请求参数的提取，这个属于指令高级篇，后面会单独开博客讲
